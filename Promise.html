<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    1111
    <a href="https://juejin.im/post/5b6161e6f265da0f8145fb72">promiseA+</a>
    <a href="https://github.com/forthealllight/blog/issues/4"> 参考链接 </a>
    <script>
        //  var p1 = new Promise((resolve,reject)=>{
        //      resolve('成功')
        //     // reject('失败')
        //  })
        //  p1.then((res)=>{
        //      console.log(res)
        //  },(reason)=>{
        //      console.log(reason)
        //  })
        //  Promise 有三个状态 pending fulfilled rejected 状态一旦改变就不可变，接受一个函数作为参数
        //  实例的then方法接受两个参数 promise.then(onFullfilled,onRejected)
        //  第一版
        // function MyPromise( constructor ){
        //    var _this = this;
        //    _this.status = 'pending'; // 初始状态
        //    _this.value =  undefined ; // 定义状态为resolved 的时候的值
        //    _this.reason = undefined ; // 定义状态为rejected 的时候的值 
        //    function resolve(value){
        //       if(_this.status == 'pending'){
        //           _this.value = value;
        //           _this.status = 'resolved'
        //       }
        //    }
        //    function reject(reason){
        //       if(_this.status == 'pending'){
        //           _this.reason = reason;
        //           _this.status = 'rejected'
        //       }
        //    }
        //    constructor(resolve,reject)
        // }
        // MyPromise.prototype.then = function( onFullfilled,onRejected ){
        //     var _this = this;
        //     console.log(_this.status)
        //     switch( _this.status ){
        //         case 'resolved':
        //         onFullfilled(_this.value);
        //         break;
        //         case 'rejected':
        //         onRejected(_this.reason);
        //         break;
        //         default:
        //         break;
        //     }
        // }

        // var p2 = new MyPromise((resolve,reject)=>{
        //     resolve('MyPromise')
        // })
        // p2.then((res)=>{
        //     console.log(res)
        // })
        // var p4 = new Promise((resolve,reject)=>{
        //     setTimeout(()=>{resolve(2000)},0)
        // })
        // p4.then((res)=>{
        //     console.log(res)
        // })
        // var p3 = new MyPromise((resolve,reject)=>{
        //     setTimeout(()=>{resolve(1000)},0)
        // })
        // setTimeout(()=>{
        //     p3.then((res)=>{
        //       console.log(res)
        //     })
        // },1000)
        // p3.then((res)=>{
        //       console.log(res)
        // })

        //  第二版 （添加异步处理）
        //  function MyPromise ( constructor ){
        //      var _this = this;
        //      _this.status = 'pending';
        //      _this.value = undefined;
        //      _this.reason = undefined;
        //      _this.onFullfilledArr = [];
        //      _this.onRejectedArr = [];
        //      function resolve (val){
        //         if(_this.status == 'pending'){
        //             _this.value = val;
        //             _this.status = 'resolved';
        //             _this.onFullfilledArr.forEach(f=>{
        //                 f()
        //             })
        //         }
        //      }
        //      function reject(val){
        //          if(_this.status == 'pending'){
        //             _this.reason = val;
        //             _this.reason = 'reject';
        //             _this.onRejectedArr.forEach(f=>{
        //                 f()
        //             })
        //          }
        //      }
        //      constructor( resolve,reject )
        //  }
        //  MyPromise.prototype.then = function ( onFullfilled,onRejected ){
        //      var _this = this
        //      console.log(_this.status)
        //      switch(_this.status){
        //          case 'pending' :
        //          _this.onFullfilledArr.push( function(){
        //              onFullfilled(_this.value);
        //          } )
        //          _this.onRejectedArr.push( function(){
        //              onRejected(_this.reason)
        //          })
        //          case 'resolved':
        //             onFullfilled(_this.value);
        //          break;
        //          case 'rejected':
        //             onRejected(_this.reason);
        //          break;
        //          default:
        //      }
        //  }

        // 第三版 （  添加链式回调 ）
        function MyPromise ( constructor ){
             var _this = this;
             _this.status = 'pending';
             _this.value = undefined;
             _this.reason = undefined;
             _this.onFullfilledArr = []; 
             _this.onRejectedArr = [];
             function resolve (val){
                if(_this.status == 'pending'){
                    _this.value = val;
                    _this.status = 'resolved';
                    _this.onFullfilledArr.forEach(f=>{
                        f()
                    })
                }
             }
             function reject(val){
                 if(_this.status == 'pending'){
                    _this.reason = val;
                    _this.reason = 'reject';
                    _this.onRejectedArr.forEach(f=>{
                        f()
                    })
                 }
             }
             constructor( resolve,reject )
         }
         MyPromise.prototype.then = function ( onFullfilled,onRejected ){
             var _this = this;
             var promise02 = undefined;
             console.log(_this.status)
             switch(_this.status){
                 case 'pending' :
                 promise02 = new MyPromise( function(resolve,reject){
                    _this.onFullfilledArr.push( function(){
                         onFullfilled(_this.value);
                    } )
                    _this.onRejectedArr.push( function(){
                        onRejected(_this.reason)
                    })
                 } )
                 case 'resolved':
                 promise02 = new MyPromise( function(resolve,reject){
                    var temple = onFullfilled(_this.value);
                    resolve(temple)
                 } )
                 break;
                 case 'rejected':
                 promise02 = new MyPromise( function(resolve,reject){
                    var temple = onRejected(_this.reason);
                    resolve(temple)
                 } )
                 break;
                 default:
             }
             return promise02;
         }
       
       let p1 = new MyPromise((resolve,reject)=>{
           resolve(1)
       })
       p1.then((res)=>{
           console.log('first then',res)
           return 2;
       }).then((res)=>{
           console.log('second then',res)
       })
       p1.then((res)=>{
           console.log('3 then',res)
       })
       
       const pp1 = new Promise((resolve,reject)=>{
           setTimeout(()=>{reject(new Error('Fail'))},1000)
       })
       const pp2 = new Promise((resolve,reject)=>{
           setTimeout(()=>{resolve(pp1)},100)
       })
        pp2.then((res)=>{
            console.log('success')
        }).catch((err)=>{
            console.log(err)
        })
    </script>
</html>