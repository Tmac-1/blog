<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <a href="https://segmentfault.com/a/1190000017420042"> reducer方法 </a>
    <script>
        // 数组扁平化
        // 斐波拉契数列(爬楼梯，10层楼梯，每次只能走一级或者两级，一共多少中走法)
        // 查找（二分查找（有序数组））[1,2,3,4,5,6,7,8] 5
        // 栈Stack 后进先出 只能操作队尾 push pop 操作    --- {(<>)} 括号匹配问题
        // 链表 Hash表
        // 找钱问题 change = new Change([1,5,10,20,50,100]) change.makeChange(13)
        // 暴力斐波拉契
        function fib(n){
            if(n==1 || n==2) return 1;
            return fib(n-1)+fib(n-2)
        }

        // 带备忘录的斐波拉契
        function fib1(n){
            let cache= []
            return helper(cache,n)
        }
        function helper(cache,n){
            if(n==1||n==2)return 1
            if(cache[n]) return cache[n]
            // 缓存保留计算结果，避免冗余计算
            cache[n] = helper(cache,n-1)+helper(cache,n-2)
            return cache[n]
        }

        // 前面两种算法都是自顶向下，动态规划要求自底向上，这样就不再使用递归
        function fib3(n){
            let dp = []
            dp[1]=dp[2]=1
            for(let i=3;i<=n;i++){
                dp[n]=dp[n-1]+dp[n-2]
            }
            return dp[n]
        }
    </script>
</body>
</html>