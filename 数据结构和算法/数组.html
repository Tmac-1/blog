<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
  </head>
  <body>
    <a href="https://segmentfault.com/a/1190000017420042"> reducer方法 </a>
    <script>
      // 数组扁平化
      var arr = [1, [2, [3, 4]]];
      function flattern(arr) {
        while (arr.some((item) => Array.isArray(item))) {
          arr = [].concat(...arr);
        }
        return arr;
      }

      // 查找（二分查找（有序数组））[1,2,3,4,5,6,7,8] 5
      var arr = [1, 2, 3, 3, 3, 4, 4, 4, 5, 6, 7, 8];
      function binaryFind(num, arr, start, end) {
        if (start <= end) {
          if (num == arr[start]) {
            return start;
          }
          if (num == arr[end]) {
            return end;
          }
          let mid = Math.ceil((start + end) / 2);
          if (num == arr[mid]) {  // 可能存在数组中好几个被选中的数
            let findArr = [];
            findArr.push(mid);
            let tem = mid;
            while (tem++) {
              if (num == arr[tem]) {
                findArr.push(tem);
              } else {
                break;
              }
            }
            tem = mid;
            while (tem--) {
              if (num == arr[tem]) {
                findArr.unshift(tem);
              } else {
                break;
              }
            }
            return findArr;
          }
          if (num < arr[mid]) {
            return binaryFind(num, arr, 0, mid - 1);
          }
          if (num > arr[mid]) {
            return binaryFind(num, arr, mid + 1, end);
          }
        }
        return -1;
      }
      console.log(binaryFind(3, arr, 0, arr.length - 1));
      // 栈Stack 后进先出 只能操作队尾 push pop 操作    --- {(<>)} 括号匹配问题
      function legalBrackets(str){
        let stack = []
        let map = {
            '{':'}',
            '[':']',
            '(':')',
        }
        for(let item of str) {
            if(map[item]) {
                stack.push(item)
            }else if(Object.values(map).includes(item)){
                let last = stack.pop()
                if(item !== map[last]) return false
            }
        }
        return stack.length == 0
      }
      console.log(legalBrackets("()")); //true
      console.log(legalBrackets("([ ) ]")); //false
      console.log(legalBrackets("([{ )]")); //false
      console.log(legalBrackets("()[ ]{}")); //true
      console.log(legalBrackets(" { ]")); //false
      console.log(legalBrackets("{ [ ] }")); //true
      console.log(legalBrackets("function a (){console.log(1111)}"))// true
      //  https://blog.csdn.net/mrdeng_web2018/article/details/108426604 
      // 链表 Hash表
      // 最少硬币找钱问题 change = new Change([1,5,10,20,50,100]) change.makeChange(13)  动态规划：动态调整全局最优解 贪心算法：只考虑局部最优解
      // https://www.jianshu.com/p/eb7bee8528cc
      // 背包问题
      // 斐波拉契数列(爬楼梯，10层楼梯，每次只能走一级或者两级，一共多少中走法)
      // 暴力斐波拉契
      function fib(n) {
        if (n == 1 || n == 2) return 1;
        return fib(n - 1) + fib(n - 2);
      }

      // 带备忘录的斐波拉契
      function fib1(n) {
        let cache = [];
        return helper(cache, n);
      }
      function helper(cache, n) {
        if (n == 1 || n == 2) return 1;
        if (cache[n]) return cache[n];
        // 缓存保留计算结果，避免冗余计算
        cache[n] = helper(cache, n - 1) + helper(cache, n - 2);
        return cache[n];
      }

      // 前面两种算法都是自顶向下，动态规划要求自底向上，这样就不再使用递归
      function fib3(n) {
        let dp = [];
        dp[1] = dp[2] = 1;
        for (let i = 3; i <= n; i++) {
          dp[n] = dp[n - 1] + dp[n - 2];
        }
        return dp[n];
      }
    </script>
  </body>
</html>
